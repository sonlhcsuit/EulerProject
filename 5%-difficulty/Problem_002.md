# Even Fibonacci numbers
#### Problems 2    
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

---
Fibonacci problem is a very similar problem to us, but I wanna to show you a few approaches to this problem.

### Approach 1
#### Using the recursion
An Fibonacci number was proposed that
```python
f(i) = f(i - 1)+ f(i - 2)
```
and f(0) = f(1) = f(2) = 1

So we can easily, write an recursive function:
```python
def f(n):
  if n==2 or n==1 or n == 0:
    return 1
  return f(n-1)+f(n-2)
```
But this approach work well with small number, it becomes slow with large number (larger than 10000)

### Approach 2
#### Using general formula (as know as Binet formula)

![[phi]](../resources/Problem_002.01.png)

![[bitnet]](../resources/Problem_002.02.png)

Remember to round the nth Fibonacci number (because when you apply this formula - you will get an real number or an float)

The weakness of this approach is floating point operation, it require a huge floating point precision dealing with big number

### Approach 3
#### Using dynamic programming

We can store all calculated fibonacci numbers in an array, and continue to calculate the new one
```python
def fibonacci(n):  
    f = [0, 1]  
    for i in range(2, n+1):
        f.append(f[i-1] + f[i-2])
    return f[n]
```

### Approach 4
#### Using power of the matrix

Another way of dynamic programming is using fibonacci matrix

![matrix power](../resources/Problem_002.03.png)
```python
def fib(n):
    F = [[1, 1],
         [1, 0]]
    if (n == 0):
        return 0
    power(F, n - 1)
    return F[0][0]

def multiply(F, M):

    x = (F[0][0] * M[0][0] +
         F[0][1] * M[1][0])
    y = (F[0][0] * M[0][1] +
         F[0][1] * M[1][1])
    z = (F[1][0] * M[0][0] +
         F[1][1] * M[1][0])
    w = (F[1][0] * M[0][1] +
         F[1][1] * M[1][1])

    F[0][0] = x
    F[0][1] = y
    F[1][0] = z
    F[1][1] = w

def power(F, n):

    M = [[1, 1],
         [1, 0]]

    # n - 1 times multiply the
    # matrix to {{1,0},{0,1}}
    for i in range(2, n + 1):
        multiply(F, M)
```

---
And this is my code for this problem
```python
def sum_even_fib(n):
    pre = 1
    mid = 1
    post = 2
    sum_ = 0
    while post < n:
        if(post % 2 == 0):
#             print(post)

            sum_+= post
        temp = post + mid
        pre = mid
        mid = post
        post = temp
    return sum_
print(sum_even_fib(4*int(1e6)))
```
